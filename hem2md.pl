#!/usr/bin/perl

use strict;
use JSON;
use Data::Dumper;

die unless (@ARGV);

my $debug = 0;
my $buffer;
my $lc=1;

open IN, $ARGV[0];
while(<IN>) {
	$buffer = $buffer.$_;
}
close IN;

my $json = JSON->new->allow_nonref;
my $hd = $json->decode( $buffer );

print $json->pretty->encode($hd) if $debug; 
print Dumper $hd if $debug;

my $bl_hd = $hd->{'blocks'};
my $entitymap = $hd->{'entityMap'};

print "<!-- This file has been automatically generated by hem2md -->\n\n\n";

# Traverse the Blocks
#
for my $k (@$bl_hd) {
	#print "$k->{'key'}\n";
	#print "$k->{'depth'}\n";
	#print "$k->{'data'}\n";
	my $type = $k->{'type'};
	my $text = $k->{'text'};

	if ($text) {
	
		# Adjust inline styles for bold and italic
		#
		my $inl = $k->{'inlineStyleRanges'};
		my $accum = 0; # The string shifts as we go...

		for my $i (@$inl) {

			my $char = '';
			my $i_style = $i->{'style'};
			my $i_length = $i->{'length'};
			my $i_offset = $i->{'offset'};
		
			# XXX this does not work for overlaps
			my $left = substr($text, 0, $i_offset+$accum);
			my $middle = substr($text, $i_offset+$accum, $i_length);
			my $right = substr($text, $i_offset+$i_length+$accum);

		#	print "L: |$left|\n";
		#	print "M: |$middle|\n";
		#	print "R: |$right|\n";

			if ($i_style eq 'ITALIC') {
				$char='*';
				$accum=$accum+2;
			} elsif ($i_style eq 'BOLD') {
				$char='**';
				$accum=$accum+4;
			} else {
				warn "Unknown style $i_style!\n";
			}
			$text = "$left$char$middle$char$right";

		}

		# Links are done in the entitymap
		#
		my $entr = $k->{'entityRanges'};
		for my $e (@$entr) {
			my $e_key = $e->{'key'};
			my $e_length = $e->{'length'};
			my $e_offset = $e->{'offset'};

			next unless $entitymap->{$e_key}->{'type'};
			my $e_type = $entitymap->{$e_key}->{'type'};
			if ($e_type eq 'LINK') {
				my $link = $entitymap->{$e_key}->{'data'}->{'href'};
				# Adjust text to use the link
								
				#substr EXPR,OFFSET,LENGTH,REPLACEMENT
				my $left = substr($text, 0, $e_offset+$accum);
				my $middle = substr($text, $e_offset+$accum, $e_length);
				my $right = substr($text, $e_offset+$e_length+$accum);
				
				$text = "$left\[$middle\]\($link\)$right";
				$accum=$accum+4+length($link);
			} else {
				warn "Unknown entity type $e_type\n";
			}


		}


		print "# " if $type eq 'header-one';
		print "## " if $type eq 'header-two';
		print "### " if $type eq 'header-three';
		print "- " if $type eq 'unordered-list-item';
		if ($type eq 'ordered-list-item') {
			print "$lc".". ";
			$lc++;
		} else { 
			$lc=1;
		}
		print "C> " if $type eq 'blockquote';
	}

	print "$text\n";
}
# Types

